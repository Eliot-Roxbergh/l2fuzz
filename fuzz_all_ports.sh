#!/bin/bash
# Fuzz all open L2CAP ports on a target bluetooth address
#
echo
echo '============================================ NOTE ============================================='
echo 'This script is terribly inefficient since L2Fuzz scans random channels most of the time.'
echo 'Only some requests (for some specific state machine state fuzzing) uses the given channel ID (i.e. PSM).'
echo "Still, as an ugly hack this doesn't hurt: if we have time, fuzzing additional random PSMs doesn't hurt."
echo
echo "If you wish to only scan given channel,"
echo "see l2cap_fuzzer.py and requests that use 'psm=port' and not 'psm=random_psm()'"
echo '============================================ NOTE ============================================='
echo

readonly services_file="l2fuzz_open_ports.tmp"
readonly bt_addr="$1"

# First argument should be a valid bluetooth address
if [ -z "$bt_addr" ]; then
	echo "Error: first argument should be Bluetooth address of target (in format 00:FF:00:FF:00:FF)"
    echo "Usage: $0 00:FF:00:FF:00:FF"
    echo
	exit 1
fi

# Just to be sure:
#   delete data from the last run,
#   in case we'd fail to catch error from l2fuzz scan and then go on to scan wrong ports
rm "$services_file" 2> /dev/null

# Discover all open L2CAP services using both manual connect and as reported by SDP
python3 l2fuzz.py "$bt_addr" scan-only

if [ $? -ne 0 ]; then
	echo "Error: l2fuzz failed, see its print out for more info"
	exit 1
fi

# Read discovered ports from file generated by
#  python3 l2fuzz.py <bt_addr> scan-only
# File format: single line, entries separated by space
# Common ports are: 1 3 5 7 15 17 19 21 23 25 27 29 31 33 35 37
read -r -a ports < "$services_file"

echo "Running fuzzer for each of the following ports: ${ports[@]}"; echo
sleep 1

# Fuzz each open port on target
for port in "${ports[@]}"; do
    echo "Running: python3 l2fuzz.py $bt_addr $port"
    echo
    python3 l2fuzz.py "$bt_addr" $port
done
