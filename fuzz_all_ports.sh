#!/bin/bash
# Fuzz all open L2CAP ports on a target bluetooth address
#
echo
echo '============================================ NOTE ============================================='
echo 'This script is terribly inefficient since L2Fuzz scans random channels most of the time.'
echo 'Only some requests (for some specific state machine state fuzzing) uses the given channel ID (i.e. PSM).'
echo "Still, as an ugly hack this doesn't hurt: if we have time, fuzzing additional random PSMs doesn't hurt."
echo
echo "If you wish to only scan given channel,"
echo "see l2cap_fuzzer.py and requests that use 'psm=port' and not 'psm=random_psm()'"
echo '============================================ NOTE ============================================='
echo

readonly services_file="l2fuzz_open_ports.tmp"
readonly bt_addr="$1"

# First argument should be a valid bluetooth address
if [ -z "$bt_addr" ]; then
	echo "Error: first argument should be Bluetooth address of target (in format 00:FF:00:FF:00:FF)"
    echo "Usage: $0 00:FF:00:FF:00:FF"
    echo
	exit 1
fi

rm "$services_file" 2> /dev/null

# Discover all open L2CAP services using both manual connect and as reported by SDP
python3 l2fuzz.py "$bt_addr" scan-only

if [ $? -ne 0 ]; then
	echo "Error: l2fuzz failed, see its print out for more info"
	exit 1
fi

# Read discovered ports from file generated by
#  python3 l2fuzz.py <bt_addr> scan-only
read -r -a ports < "$services_file"

# Fuzz each open port on target
for port in "${ports[@]}"; do
    echo "Running: python3 l2fuzz.py $bt_addr $port"
    echo
    python3 l2fuzz.py "$bt_addr" $port
done
